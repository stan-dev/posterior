#' Weight `draws` objects
#'
#' Add weights to [`draws`] objects, with one weight per draw, for use in
#' subsequent weighting operations. For reasons of numerical accuracy, weights
#' are stored in the form of unnormalized log-weights (in a variable called
#' `.log_weight`). See [weights.draws()] for details how to extract weights from
#' `draws` objects.
#'
#' @template args-methods-x
#' @param weights (numeric vector) A vector of weights of length `ndraws(x)`,
#'   or `NULL` to remove weights. Weights will be internally stored on the log
#'   scale and will not be normalized. Normalized (non-log) weights can be
#'   returned via the [weights.draws()] method, and the unnormalized
#'   log weights can be accessed via [log_weights()].
#' @param log (logical) Are the weights passed already on the log scale? The
#'   default is `FALSE`, that is, expecting `weights` to be on the standard
#'   (non-log) scale.
#' @param pareto_smooth (logical) Should the weights be Pareto-smoothed?
#' The default is `FALSE`.
#' @template args-methods-dots
#' @template return-draws
#'
#' @seealso [weights.draws()], [resample_draws()]
#'
#' @examples
#' x <- example_draws()
#'
#' # sample some random weights for illustration
#' wts <- rexp(ndraws(x))
#' head(wts)
#'
#' # add weights
#' x <- weight_draws(x, weights = wts)
#'
#' # extract weights
#' head(weights(x)) # defaults to normalized weights
#' head(weights(x, normalize=FALSE)) # recover original weights
#' head(weights(x, log=TRUE)) # get normalized log-weights
#'
#' # add weights which are already on the log scale
#' log_wts <- log(wts)
#' head(log_wts)
#'
#' x <- weight_draws(x, weights = log_wts, log = TRUE)
#' # extract weights
#' head(weights(x))
#' head(weights(x, log=TRUE, normalize = FALSE)) # recover original log_wts
#'
#' # log_weights(x) is equivalent to weights(x, log = TRUE, normalize = FALSE)
#' all.equal(log_weights(x), weights(x, log = TRUE, normalize = FALSE))
#'
#' # add weights on log scale and Pareto smooth them
#' x <- weight_draws(x, weights = log_wts, log = TRUE, pareto_smooth = TRUE)
#'
#' @export
weight_draws <- function(x, weights, ...) {
  UseMethod("weight_draws")
}

#' @rdname weight_draws
#' @export
weight_draws.draws_matrix <- function(x, weights, log = FALSE, pareto_smooth = FALSE, ...) {
  log_weights <- validate_weights(weights, ndraws(x), log, pareto_smooth)
  if (is.null(weights)) return(remove_variables(x, ".log_weight"))

  if (".log_weight" %in% variables(x, reserved = TRUE)) {
    # overwrite existing weights
    x[, ".log_weight"] <- log_weights
  } else {
    # add weights as a new variable
    log_weights <- draws_matrix(.log_weight = log_weights, .nchains = nchains(x))
    x <- bind_draws(x, log_weights)
  }
  x
}

#' @rdname weight_draws
#' @export
weight_draws.draws_array <- function(x, weights, log = FALSE, pareto_smooth = FALSE, ...) {
  log_weights <- validate_weights(weights, ndraws(x), log, pareto_smooth)
  if (is.null(weights)) return(remove_variables(x, ".log_weight"))

  if (".log_weight" %in% variables(x, reserved = TRUE)) {
    # overwrite existing weights
    x[, , ".log_weight"] <- log_weights
  } else {
    # add weights as a new variable
    log_weights <- draws_array(.log_weight = log_weights, .nchains = nchains(x))
    x <- bind_draws(x, log_weights)
  }
  x
}

#' @rdname weight_draws
#' @export
weight_draws.draws_df <- function(x, weights, log = FALSE, pareto_smooth = FALSE, ...) {
  x$.log_weight <- validate_weights(weights, ndraws(x), log, pareto_smooth)
  x
}

#' @rdname weight_draws
#' @export
weight_draws.draws_list <- function(x, weights, log = FALSE, pareto_smooth = FALSE, ...) {
  log_weights <- validate_weights(weights, ndraws(x), log, pareto_smooth)
  if (is.null(log_weights)) return(remove_variables(x, ".log_weight"))

  niterations <- niterations(x)
  for (i in seq_len(nchains(x))) {
    sel <- (1 + (i - 1) * niterations):(i * niterations)
    x[[i]]$.log_weight <- log_weights[sel]
  }
  x
}

#' @rdname weight_draws
#' @export
weight_draws.draws_rvars <- function(x, weights, log = FALSE, pareto_smooth = FALSE, ...) {
  .log_weights <- validate_weights(weights, ndraws(x), log, pareto_smooth)
  for (i in seq_along(x)) {
    log_weights_rvar(x[[i]]) <- .log_weights
  }
  x
}

#' @rdname weight_draws
#' @export
weight_draws.rvar <- function(x, weights, log = FALSE, pareto_smooth = FALSE, ...) {
  log_weights_rvar(x) <- validate_weights(weights, ndraws(x), log, pareto_smooth)
  x
}

#' Extract Weights from Draws Objects
#'
#' Extract weights from [`draws`] objects, with one weight per draw.
#' See [`weight_draws`] for details how to add weights to [`draws`] objects.
#' `log_weights(x)` is a low-level shortcut for `weights(x, log = TRUE, normalize = FALSE)`,
#' returning the internal log weights without transforming them.
#'
#' @param object (draws) A [`draws`] object or an [`rvar`].
#' @param log (logical) Should the weights be returned on the log scale?
#'   Defaults to `FALSE`.
#' @param normalize (logical) Should the weights be normalized to sum to 1 on
#'   the standard scale? Defaults to `TRUE`.
#' @template args-methods-dots
#'
#' @return A vector of weights, with one weight per draw, or `NULL` if this
#'   object does not contain weights.
#'
#' @seealso [`weight_draws`], [`resample_draws`]
#'
#' @inherit weight_draws examples
#'
#' @export
weights.draws <- function(object, log = FALSE, normalize = TRUE, ...) {
  log <- as_one_logical(log)
  normalize <- as_one_logical(normalize)

  out <- log_weights(object)
  if (is.null(out)) return(NULL)

  if (normalize) {
    out <- out - log_sum_exp(out)
  }
  if (!log) {
    out <- exp(out)
  }
  out
}

#' @rdname weights.draws
#' @export
weights.rvar <- weights.draws

#' @rdname weights.draws
#' @export
log_weights <- function(object, ...) {
  UseMethod("log_weights")
}

#' @rdname weights.draws
#' @export
log_weights.draws <- function(object, ...) {
  if (!".log_weight" %in% variables(object, reserved = TRUE)) {
    return(NULL)
  }
  extract_variable(object, ".log_weight")
}

#' @rdname weights.draws
#' @export
log_weights.draws_rvars <- function(object, ...) {
  if (length(object) < 1) return(NULL)
  log_weights(object[[1]])
}

#' @rdname weights.draws
#' @export
log_weights.rvar <- function(object, ...) {
  attr(object, "log_weights")
}
# for internal use only currently: if you are setting the log_weights
# attribute on an rvar, ALWAYS use this function so that the proxy
# cache is invalidated
`log_weights_rvar<-` <- function(x, value) {
  if (!identical(attr(x, "log_weights"), value)) {
    attr(x, "log_weights") <- value
    x <- invalidate_rvar_cache(x)
  }
  x
}


# validate weights and return log weights
validate_weights <- function(weights, ndraws, log = FALSE, pareto_smooth = FALSE) {
  if (is.null(weights)) return(NULL)
  checkmate::assert_numeric(weights)
#  checkmate::assert_atomic_vector(weights)
  checkmate::assert_flag(log)
  checkmate::assert_flag(pareto_smooth)

  if (length(weights) != ndraws) {
    stop_no_call("Number of weights must match the number of draws.")
  }
  if (any(weights == Inf)) {
    stop_no_call("Weights must not be positive infinite.")
  }
  if (!log) {
    if (any(weights < 0)) {
      stop_no_call("Weights must be non-negative.")
    }
    weights <- log(weights)
  }
  if (pareto_smooth) {
    weights <- pareto_smooth_log_weights(weights)
  }

  weights
}


pareto_smooth_log_weights <- function(log_weights) {
  pareto_smooth(
    log_weights,
    tail = "right",
    return_k = TRUE,
    are_log_weights = TRUE,
    extra_diags = TRUE
  )$x
}
